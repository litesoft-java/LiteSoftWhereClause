// This Source Code is in the Public Domain per: http://unlicense.org
package org.litesoft.whereclause;

import org.litesoft.whereclause.nonpublic.*;

import java.util.*;

/**
 * A Factory to generate a representation of a SQL <i>WHERE</i> clause.<p>
 * <a href="../../Licence.txt">Licence</a><br>
 * <p/>
 * Using this Factory a complex SQL <i>WHERE</i> clause can be generated.
 * The concrete extensions of <b>WhereClause</b> generated by this Factory
 * can form a <i>tree</i> that represents any arbitrarily complex expression.<p>
 * <p/>
 * If you need to create/support a specific SQL <i>WHERE</i> clause that
 * is not provided, you would need to extend this class and probably one of
 * the abstract <b>WhereClause</b> helper classes listed in <b>WhereClause</b>.<p>
 * <p/>
 * See <a href="WhereClause.html">WhereClause</a><p>
 * <p/>
 * Exceptions: All problems caught when the parameter(s) are checked (as
 * indicated/implied in the @param tags) will generate an IllegalArgumentException,
 * and means the API user has a problem.  If a NullPointerException (or some
 * others, like: ClassCastException or ArrayIndexOutOfBoundsException) is thrown,
 * it means the API developer has a problem.  Any Exception that is explicitly
 * thrown in the API, but unrelated to a parameter, will be listed in the throws
 * clause (and hopefully in the tag @throws).  These may (but probably won't) be
 * checked Exceptions.
 *
 * @author George Smith
 * @version 1.0 10/07/01
 */

public class WhereClauseFactory {
    public static WhereClauseFactory INSTANCE = new WhereClauseFactory();

    /**
     * Return an <b>OR</b> SQL <i>WHERE</i> clause of two other <i>WHERE</i> clauses.<p>
     * <p/>
     * Note: If either (or both) of the two <b>WhereClause</b>s are them selves
     * <i>OR</i> <b>WhereClause</b>s then, the <b>WhereClause</b>(s) are
     * <i>merged</i> (collapsed to this new one).<p>
     *
     * @param pWhereClause1 First of the two <i>WHERE</i> clauses (!null).
     * @param pWhereClause2 Second of the two <i>WHERE</i> clauses (!null).<p>
     *
     * @return <b>OR</b> merged <b>WhereClause</b>s.
     */
    public WhereClause or( WhereClause pWhereClause1, WhereClause pWhereClause2, WhereClause... pWhereClauseMore ) {
        WhereClause wc = WC_OR.create( pWhereClause1, pWhereClause2 );
        if ( (pWhereClauseMore != null) && (pWhereClauseMore.length != 0) ) {
            for ( WhereClause clause : pWhereClauseMore ) {
                wc = WC_OR.create( wc, clause );
            }
        }
        return wc;
    }

    /**
     * Return an <b>AND</b> SQL <i>WHERE</i> clause of two other <i>WHERE</i> clauses.<p>
     * <p/>
     * Note: If either (or both) of the two <b>WhereClause</b>s are them selves
     * <i>AND</i> <b>WhereClause</b>s then, the <b>WhereClause</b>(s) are
     * <i>merged</i> (collapsed to this new one).<p>
     *
     * @param pWhereClause1 First of the two <i>WHERE</i> clauses (!null).
     * @param pWhereClause2 Second of the two <i>WHERE</i> clauses (!null).<p>
     *
     * @return <b>AND</b> merged <b>WhereClause</b>s.
     */
    public WhereClause and( WhereClause pWhereClause1, WhereClause pWhereClause2, WhereClause... pWhereClauseMore ) {
        WhereClause wc = WC_AND.create( pWhereClause1, pWhereClause2 );
        if ( (pWhereClauseMore != null) && (pWhereClauseMore.length != 0) ) {
            for ( WhereClause clause : pWhereClauseMore ) {
                wc = WC_AND.create( wc, clause );
            }
        }
        return wc;
    }

    /**
     * Return a <b>NOT</b><i>ed</i> SQL <i>WHERE</i> clause.<p>
     *
     * @param pWhereClause The WhereClause that is to be <b>NOT</b><i>ed</i> (!null).<p>
     *
     * @return <b>NOT</b><i>ed</i> WhereClause.
     */
    public WhereClause not( WhereClause pWhereClause ) {
        if ( pWhereClause instanceof WhereClauseNotable ) {
            ((WhereClauseNotable) pWhereClause).switchNot();
            return pWhereClause;
        }
        if ( pWhereClause == WC_TRUE.INSTANCE ) {
            return WC_FALSE.INSTANCE;
        }
        if ( pWhereClause == WC_FALSE.INSTANCE ) {
            return WC_TRUE.INSTANCE;
        }
        return new WC_NOT( pWhereClause );
    }

    public WhereClause alwaysTrue() {
        return WC_TRUE.INSTANCE;
    }

    public WhereClause alwaysFalse() {
        return WC_FALSE.INSTANCE;
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a column is
     * <i>NULL</i>.<p>
     *
     * @param pColumnDefinition Column Definition (!null).<p>
     *
     * @return NULL WhereClause.
     */
    public WhereClause isNull( SimpleColumnDefinition pColumnDefinition ) {
        return new WC_IS_NULL( pColumnDefinition );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a column is
     * <i>NOT NULL</i>.<p>
     *
     * @param pColumnDefinition Column Definition (!null).<p>
     *
     * @return NOT NULL WhereClause.<p>
     *
     * @see #not(WhereClause)
     * @see #isNull(SimpleColumnDefinition)
     */
    public WhereClause isNotNull( SimpleColumnDefinition pColumnDefinition ) {
        return not( isNull( pColumnDefinition ) );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a column is
     * <i>equal to</i> any of the collection's value(s).<p>
     * <p/>
     * Note: Due to the pecular nature of Java's <i>null</i> and the SQL NULL,
     * the resulting SQL <i>WHERE</i> clause may include "IS NULL".<p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pValues           Compare with values (at least one value).<p>
     *
     * @return Any Of WhereClause.<p>
     *
     * @see #isNull(SimpleColumnDefinition)
     * @see #isEqual(SimpleColumnDefinition, Object)
     */
    public WhereClause isAnyFrom( SimpleColumnDefinition pColumnDefinition, Collection<?> pValues ) {
        return LLisAnyFrom( pColumnDefinition, (pValues != null) ? pValues : Collections.EMPTY_LIST );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a column is
     * <i>NOT equal to</i> any of the collection's value(s).<p>
     * <p/>
     * Note: Due to the pecular nature of Java's <i>null</i> and the SQL NULL,
     * the resulting SQL <i>WHERE</i> clause may include "IS NOT NULL" or
     * will <i>or</i> in an "IS NULL".<p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pValues           Compare with values (at least one value).<p>
     *
     * @return NOT Any Of WhereClause.<p>
     *
     * @see #not(WhereClause)
     * @see #isEqual(SimpleColumnDefinition, Object)
     * @see #isNotNull(SimpleColumnDefinition)
     * @see #isNull(SimpleColumnDefinition)
     * @see #or(WhereClause, WhereClause, WhereClause[])
     */
    public WhereClause isNotAnyFrom( SimpleColumnDefinition pColumnDefinition, Collection<Object> pValues ) {
        return not( isAnyFrom( pColumnDefinition, pValues ) );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a column is
     * <i>equal to</i> any of the Object value(s).<p>
     * <p/>
     * Note: Due to the pecular nature of Java's <i>null</i> and the SQL NULL,
     * the resulting SQL <i>WHERE</i> clause may include "IS NULL".<p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pValues           Compare with values (at least one value).<p>
     *
     * @return Any Of WhereClause.<p>
     *
     * @see #isNull(SimpleColumnDefinition)
     * @see #isEqual(SimpleColumnDefinition, Object)
     */
    public WhereClause isAnyOf( SimpleColumnDefinition pColumnDefinition, Object... pValues ) {
        return LLisAnyFrom( pColumnDefinition, //
                            (pValues == null) || (pValues.length == 0) ? //
                            Collections.EMPTY_LIST : //
                            Arrays.asList( pValues ) );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a column is
     * <i>NOT equal to</i> any of the Object value(s).<p>
     * <p/>
     * Note: Due to the pecular nature of Java's <i>null</i> and the SQL NULL,
     * the resulting SQL <i>WHERE</i> clause may include "IS NOT NULL" or
     * will <i>or</i> in an "IS NULL".<p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pValues           Compare with values (at least one value).<p>
     *
     * @return NOT Any Of WhereClause.<p>
     *
     * @see #not(WhereClause)
     * @see #isEqual(SimpleColumnDefinition, Object)
     * @see #isNotNull(SimpleColumnDefinition)
     * @see #isNull(SimpleColumnDefinition)
     * @see #or(WhereClause, WhereClause, WhereClause[])
     */
    public WhereClause isNotAnyOf( SimpleColumnDefinition pColumnDefinition, Object... pValues ) {
        return not( isAnyOf( pColumnDefinition, pValues ) );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a column is
     * <i>equal to</i> an Object value.<p>
     * <p/>
     * Note: Due to the pecular nature of Java's <i>null</i> and the SQL NULL,
     * the resulting SQL <i>WHERE</i> clause may become "IS NULL".<p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pValue            Compare with value.<p>
     *
     * @return equal to WhereClause.<p>
     *
     * @see #isNull(SimpleColumnDefinition)
     */
    public WhereClause isEqual( SimpleColumnDefinition pColumnDefinition, Object pValue ) {
        if ( pValue == null ) {
            return isNull( pColumnDefinition );
        }

        return new WC_EQUALS( pColumnDefinition, pValue );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a column is
     * <i>equal to</i> an <b>int</b> value.<p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pInt              Compare with int.<p>
     *
     * @return equal to WhereClause.<p>
     *
     * @see #isEqual(SimpleColumnDefinition, Object)
     */
    public WhereClause isEqual( SimpleColumnDefinition pColumnDefinition, int pInt ) {
        return isEqual( pColumnDefinition, new Integer( pInt ) );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a column is
     * <i>NOT equal to</i> an Object value.<p>
     * <p/>
     * Note: Due to the pecular nature of Java's <i>null</i> and the SQL NULL,
     * the resulting SQL <i>WHERE</i> clause will either be "IS NOT NULL" or
     * will <i>or</i> in an "IS NULL".<p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pValue            Compare with value.<p>
     *
     * @return NOT equal to WhereClause.<p>
     *
     * @see #not(WhereClause)
     * @see #isEqual(SimpleColumnDefinition, Object)
     * @see #isNotNull(SimpleColumnDefinition)
     * @see #isNull(SimpleColumnDefinition)
     * @see #or(WhereClause, WhereClause, WhereClause[])
     */
    public WhereClause isNotEqual( SimpleColumnDefinition pColumnDefinition, Object pValue ) {
        return not( isEqual( pColumnDefinition, pValue ) );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a column is
     * <i>NOT equal to</i> an <b>int</b> value.<p>
     * <p/>
     * Note: Due to the pecular nature of SQL NULLs, the resulting SQL
     * <i>WHERE</i> clause will <i>or</i> in an "IS NULL".<p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pInt              Compare with int.<p>
     *
     * @return NOT equal to WhereClause.<p>
     *
     * @see #not(WhereClause)
     * @see #isEqual(SimpleColumnDefinition, int)
     * @see #isNull(SimpleColumnDefinition)
     * @see #or(WhereClause, WhereClause, WhereClause[])
     */
    public WhereClause isNotEqual( SimpleColumnDefinition pColumnDefinition, int pInt ) {
        return not( isEqual( pColumnDefinition, pInt ) );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a column is
     * <i>less than or equal to</i> an Object value.<p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pValue            Compare with value (!null).<p>
     *
     * @return less than WhereClause.
     */
    public WhereClause isLessThanEqual( SimpleColumnDefinition pColumnDefinition, Object pValue ) {
        return isNotGreaterThan( pColumnDefinition, pValue );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a column is
     * <i>less than or equal to</i> an <b>int</b> value.<p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pInt              Compare with int.<p>
     *
     * @return less than to WhereClause.<p>
     *
     * @see #isLessThan(SimpleColumnDefinition, Object)
     */
    public WhereClause isLessThanEqual( SimpleColumnDefinition pColumnDefinition, int pInt ) {
        return isLessThanEqual( pColumnDefinition, new Integer( pInt ) );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a column is
     * <i>less than</i> an Object value.<p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pValue            Compare with value (!null).<p>
     *
     * @return less than WhereClause.
     */
    public WhereClause isLessThan( SimpleColumnDefinition pColumnDefinition, Object pValue ) {
        return new WC_LESSTHAN( pColumnDefinition, pValue );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a column is
     * <i>less than</i> an <b>int</b> value.<p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pInt              Compare with int.<p>
     *
     * @return less than to WhereClause.<p>
     *
     * @see #isLessThan(SimpleColumnDefinition, Object)
     */
    public WhereClause isLessThan( SimpleColumnDefinition pColumnDefinition, int pInt ) {
        return isLessThan( pColumnDefinition, new Integer( pInt ) );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a column is
     * <i>greater than or equal to</i> an Object value.<p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pValue            Compare with value (!null).<p>
     *
     * @return greater than or equal to WhereClause.<p>
     *
     * @see #not(WhereClause)
     * @see #isLessThan(SimpleColumnDefinition, Object)
     */
    public WhereClause isNotLessThan( SimpleColumnDefinition pColumnDefinition, Object pValue ) {
        return not( isLessThan( pColumnDefinition, pValue ) );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a column is
     * <i>greater than or equal to</i> an <b>int</b> value.<p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pInt              Compare with int.<p>
     *
     * @return greater than or equal to WhereClause.<p>
     *
     * @see #not(WhereClause)
     * @see #isLessThan(SimpleColumnDefinition, int)
     */
    public WhereClause isNotLessThan( SimpleColumnDefinition pColumnDefinition, int pInt ) {
        return not( isLessThan( pColumnDefinition, pInt ) );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a column is
     * <i>greater than or equal to</i> an Object value.<p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pValue            Compare with value (!null).<p>
     *
     * @return greater than to WhereClause.
     */
    public WhereClause isGreaterThanEqual( SimpleColumnDefinition pColumnDefinition, Object pValue ) {
        return isNotLessThan( pColumnDefinition, pValue );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a column is
     * <i>greater than or equal to</i> an <b>int</b> value.<p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pInt              Compare with int.<p>
     *
     * @return greater than to WhereClause.<p>
     *
     * @see #isGreaterThan(SimpleColumnDefinition, Object)
     */
    public WhereClause isGreaterThanEqual( SimpleColumnDefinition pColumnDefinition, int pInt ) {
        return isGreaterThanEqual( pColumnDefinition, new Integer( pInt ) );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a column is
     * <i>greater than</i> an Object value.<p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pValue            Compare with value (!null).<p>
     *
     * @return greater than to WhereClause.
     */
    public WhereClause isGreaterThan( SimpleColumnDefinition pColumnDefinition, Object pValue ) {
        return new WC_GREATERTHAN( pColumnDefinition, pValue );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a column is
     * <i>greater than</i> an <b>int</b> value.<p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pInt              Compare with int.<p>
     *
     * @return greater than to WhereClause.<p>
     *
     * @see #isGreaterThan(SimpleColumnDefinition, Object)
     */
    public WhereClause isGreaterThan( SimpleColumnDefinition pColumnDefinition, int pInt ) {
        return isGreaterThan( pColumnDefinition, new Integer( pInt ) );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a column is
     * <i>less than or equal to</i> an Object value.<p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pValue            Compare with value (!null).<p>
     *
     * @return less than or equal to WhereClause.<p>
     *
     * @see #not(WhereClause)
     * @see #isGreaterThan(SimpleColumnDefinition, Object)
     */
    public WhereClause isNotGreaterThan( SimpleColumnDefinition pColumnDefinition, Object pValue ) {
        return not( isGreaterThan( pColumnDefinition, pValue ) );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a column is
     * <i>less than or equal to</i> an <b>int</b> value.<p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pInt              Compare with int.<p>
     *
     * @return less than or equal to WhereClause.<p>
     *
     * @see #not(WhereClause)
     * @see #isGreaterThan(SimpleColumnDefinition, int)
     */
    public WhereClause isNotGreaterThan( SimpleColumnDefinition pColumnDefinition, int pInt ) {
        return not( isGreaterThan( pColumnDefinition, pInt ) );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a column is
     * <i>between</i> (INCLUSIVE) two (Object) values.<p>
     * <p/>
     * Note: if the <i>left</i> and <i>right</i> values are equal, then the
     * WhereClause is of type isEqual.<p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pGEvalue          Greater Than or Equal (left) value (!null).
     * @param pLEvalue          Less Than or Equal (right) value (!null).<p>
     *
     * @return <b>BETWEEN</b> (or equal) WhereClause.<p>
     *
     * @see #isEqual(SimpleColumnDefinition, Object)
     */
    public WhereClause isBetween( SimpleColumnDefinition pColumnDefinition, Object pGEvalue, Object pLEvalue ) {
        if ( (pGEvalue == pLEvalue) || ((pGEvalue != null) && pGEvalue.equals( pLEvalue )) ) {
            return isEqual( pColumnDefinition, pGEvalue );
        }

        return new WC_BETWEEN( pColumnDefinition, pGEvalue, pLEvalue );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a column is
     * <i>between</i> (INCLUSIVE) two <b>int</b> values.<p>
     * <p/>
     * Note: if the <i>left</i> and <i>right</i> ints are equal, then the
     * WhereClause is of type isEqual.<p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pGEint            Greater Than or Equal (left) value.
     * @param pLEint            Less Than or Equal (right) value.<p>
     *
     * @return <b>BETWEEN</b> (or equal) WhereClause.<p>
     *
     * @see #isBetween(SimpleColumnDefinition, Object, Object)
     * @see #isEqual(SimpleColumnDefinition, int)
     */
    public WhereClause isBetween( SimpleColumnDefinition pColumnDefinition, int pGEint, int pLEint ) {
        if ( pGEint == pLEint ) {
            return isEqual( pColumnDefinition, pGEint );
        }

        return isBetween( pColumnDefinition, new Integer( pGEint ), new Integer( pLEint ) );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a column is Not
     * <i>between</i> (INCLUSIVE) two (Object) values.<p>
     * <p/>
     * Note: if the <i>left</i> and <i>right</i> values are equal, then the
     * WhereClause is of type isNotEqual.<p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pGEvalue          Greater Than or Equal (left) value (!null).
     * @param pLEvalue          Less Than or Equal (right) value (!null).<p>
     *
     * @return <b>NOT BETWEEN</b> (or not equal) WhereClause.<p>
     *
     * @see #not(WhereClause)
     * @see #isBetween(SimpleColumnDefinition, Object, Object)
     * @see #isNotEqual(SimpleColumnDefinition, Object)
     */
    public WhereClause isNotBetween( SimpleColumnDefinition pColumnDefinition, Object pGEvalue, Object pLEvalue ) {
        return not( isBetween( pColumnDefinition, pGEvalue, pLEvalue ) );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a column is Not
     * <i>between</i> (INCLUSIVE) two <b>int</b> values.<p>
     * <p/>
     * Note: if the <i>left</i> and <i>right</i> ints are equal, then the
     * WhereClause is of type isNotEqual.<p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pGEint            Greater Than or Equal (left) value.
     * @param pLEint            Less Than or Equal (right) value.<p>
     *
     * @return <b>NOT BETWEEN</b> (or not equal) WhereClause.<p>
     *
     * @see #not(WhereClause)
     * @see #isBetween(SimpleColumnDefinition, int, int)
     * @see #isNotEqual(SimpleColumnDefinition, int)
     */
    public WhereClause isNotBetween( SimpleColumnDefinition pColumnDefinition, int pGEint, int pLEint ) {
        return not( isBetween( pColumnDefinition, pGEint, pLEint ) );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a String column
     * <i>contains</i> a particular set of characters.<p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pValue            String that carries the particular set of characters for checking (!null).<p>
     *
     * @return <b>LIKE</b> (any where) WhereClause.
     */
    public WhereClause contains( SimpleColumnDefinition pColumnDefinition, String pValue ) {
        return new WC_CONTAINS( pColumnDefinition, pValue );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a String column
     * does Not <i>contain</i> a particular set of characters.<p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pValue            String that carries the particular set of characters for checking (!null).<p>
     *
     * @return <b>NOT LIKE</b> (any where) WhereClause.<p>
     *
     * @see #not(WhereClause)
     * @see #contains(SimpleColumnDefinition, String)
     */
    public WhereClause doesNotContain( SimpleColumnDefinition pColumnDefinition, String pValue ) {
        return not( contains( pColumnDefinition, pValue ) );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a String column
     * <i>Starts With</i> a particular set of characters.<p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pValue            String that carries the particular set of characters for checking (!null).<p>
     *
     * @return <b>LIKE</b> (on front) WhereClause.
     */
    public WhereClause startsWith( SimpleColumnDefinition pColumnDefinition, String pValue ) {
        return new WC_STARTS_WITH( pColumnDefinition, pValue );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a String column
     * does Not <i>Start With</i> a particular set of characters.<p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pValue            String that carries the particular set of characters for checking (!null).<p>
     *
     * @return <b>NOT LIKE</b> (on front) WhereClause.<p>
     *
     * @see #not(WhereClause)
     * @see #startsWith(SimpleColumnDefinition, String)
     */
    public WhereClause doesNotStartWith( SimpleColumnDefinition pColumnDefinition, String pValue ) {
        return not( startsWith( pColumnDefinition, pValue ) );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a String column
     * <i>Ends With</i> a particular set of characters.<p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pValue            String that carries the particular set of characters for checking (!null).<p>
     *
     * @return <b>LIKE</b> (on end) WhereClause.
     */
    public WhereClause endsWith( SimpleColumnDefinition pColumnDefinition, String pValue ) {
        return new WC_ENDS_WITH( pColumnDefinition, pValue );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a String column
     * does Not <i>End With</i> a particular set of characters.<p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pValue            String that carries the particular set of characters for checking (!null).<p>
     *
     * @return <b>NOT LIKE</b> (on end) WhereClause.<p>
     *
     * @see #not(WhereClause)
     * @see #endsWith(SimpleColumnDefinition, String)
     */
    public WhereClause doesNotEndWith( SimpleColumnDefinition pColumnDefinition, String pValue ) {
        return not( endsWith( pColumnDefinition, pValue ) );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a String column
     * <i>startsWith</i>, <i>contains</i>..., and <i>endsWith</i> a particular set of character strings.<p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pValues           Strings that carries the particular set of character strings for checking (!null & !0 length).<p>
     *
     * @return <b>LIKE</b> (sequences) WhereClause.
     */
    public WhereClause like( SimpleColumnDefinition pColumnDefinition, String... pValues ) {
        if ( (pValues == null) || (pValues.length == 0) ) {
            throw IllegalArgument.exception( "Values", "NOT at least 1 String" );
        }

        if ( pValues.length > 2 ) {
            pValues = removeMiddleEmpties( pValues );
        }
        switch ( pValues.length ) {
            case 0: // Not Possible - Guard Condition above
            case 1:
                return isEqual( pColumnDefinition, pValues[0] );
            case 2:
                if ( isEmpty( pValues[0] ) ) {
                    if ( isEmpty( pValues[1] ) ) {
                        return alwaysTrue();
                    }
                    return endsWith( pColumnDefinition, pValues[1] );
                }
                if ( isEmpty( pValues[1] ) ) {
                    return startsWith( pColumnDefinition, pValues[0] );
                }
                break;
            case 3:
                if ( isEmpty( pValues[0] ) && isEmpty( pValues[2] ) ) {
                    return contains( pColumnDefinition, pValues[1] );
                }
                break;
            default:
                break;
        }
        return new WC_LIKE( pColumnDefinition, pValues );
    }

    private String[] removeMiddleEmpties( String[] pValues ) {
        int i = pValues.length - 1;
        while ( --i > 0 ) {
            if ( isEmpty( pValues[i] ) ) {
                break;
            }
        }
        if ( i == 0 ) // No Middle Empties
        {
            return pValues;
        }
        List<String> zParts = new ArrayList<String>( Arrays.asList( pValues ) );
        // i is Last empty
        zParts.remove( i );
        while ( --i > 0 ) {
            if ( isEmpty( pValues[i] ) ) // Working from the back, both pValues & zParts remain in sync!!
            {
                zParts.remove( i );
            }
        }
        return zParts.toArray( new String[zParts.size()] );
    }

    /**
     * Create a SQL <i>WHERE</i> clause that checks that a String column
     * does Not  <i>startsWith</i>, <i>contains</i>..., and <i>endsWith</i> a particular set of character strings.
     * Note <p>
     *
     * @param pColumnDefinition Column Definition (!null).
     * @param pValues           Strings that carries the particular set of character strings for checking (!null & !0 length).<p>
     *
     * @return <b>NOT LIKE</b> (sequences) WhereClause.<p>
     *
     * @see #not(WhereClause)
     * @see #like(SimpleColumnDefinition, String[])
     */
    public WhereClause isNotLike( SimpleColumnDefinition pColumnDefinition, String... pValues ) {
        return not( like( pColumnDefinition, pValues ) );
    }

    /**
     * Create a SQL <b>IN</b> <i>WHERE</i> clause.<p>
     * <p/>
     * Note: the Column Types of the ColumnDefinition and selected column of
     * the SingleColumnSelect MUST be equal, otherwise an IllegalArgumentException
     * is thrown.<p>
     *
     * @param pColumnDefinition   Column Definition (!null).
     * @param pSingleColumnSelect A single column mini-SELECT command (!null).<p>
     *
     * @return <b>IN</b> WhereClause.
     */
    public WhereClause isIn( SimpleColumnDefinition pColumnDefinition, SingleColumnSelect pSingleColumnSelect ) {
        return new WC_IS_IN( pColumnDefinition, pSingleColumnSelect );
    }

    /**
     * Create a SQL <b>NOT IN</b> <i>WHERE</i> clause.<p>
     * <p/>
     * Note: the Column Types of the ColumnDefinition and selected column of
     * the SingleColumnSelect MUST be equal, otherwise an IllegalArgumentException
     * is thrown.<p>
     *
     * @param pColumnDefinition   Column Definition (!null).
     * @param pSingleColumnSelect A single column mini-SELECT command (!null).<p>
     *
     * @return <b>NOT IN</b> WhereClause.<p>
     *
     * @see #not(WhereClause)
     * @see #isIn(SimpleColumnDefinition, SingleColumnSelect)
     */
    public WhereClause isNotIn( SimpleColumnDefinition pColumnDefinition, SingleColumnSelect pSingleColumnSelect ) {
        return not( isIn( pColumnDefinition, pSingleColumnSelect ) );
    }

    private boolean isEmpty( String pPart ) {
        return (pPart == null) || (pPart.length() == 0);
    }

    private WhereClause LLisAnyFrom( SimpleColumnDefinition pColumnDefinition, Collection<?> pValues ) {
        Set<Object> zSet = new LinkedHashSet<Object>( pValues );
        boolean hasNull = false;
        if ( zSet.contains( null ) ) {
            hasNull = true;
            zSet.remove( null );
        }
        if ( zSet.isEmpty() ) // All Nulls
        {
            return hasNull ? isNull( pColumnDefinition ) : alwaysFalse();
        }
        Object[] zValues = zSet.toArray();
        WhereClause wc = (zValues.length == 1) ? //
                         isEqual( pColumnDefinition, zValues[0] ) : //
                         new WC_IS_ANY_OF( pColumnDefinition, zValues );
        return hasNull ? or( wc, isNull( pColumnDefinition ) ) : wc;
    }

    private static void verifyNotNull( WhereClause pWhereClause1, WhereClause pWhereClause2 ) {
        verifyNotNull( pWhereClause1 );
        verifyNotNull( pWhereClause2 );
    }

    private static void verifyNotNull( WhereClause pWhereClause ) {
        if ( pWhereClause == null ) {
            throw new NullPointerException();
        }
    }

    // static inner classes to "leverage" the automatic namespacing...

    private static class WC_OR extends AbstractWhereClauseAssociativeList {
        static WhereClause create( WhereClause pWhereClause1, WhereClause pWhereClause2 ) {
            verifyNotNull( pWhereClause1, pWhereClause2 );
            if ( pWhereClause1 == WC_TRUE.INSTANCE ) {
                return pWhereClause1;
            }
            if ( pWhereClause2 == WC_TRUE.INSTANCE ) {
                return pWhereClause2;
            }
            return (pWhereClause1 == WC_FALSE.INSTANCE) ? pWhereClause2 : //
                   (pWhereClause2 == WC_FALSE.INSTANCE) ? pWhereClause1 : //
                   new WC_OR( pWhereClause1, pWhereClause2 );
        }

        private WC_OR( WhereClause pWhereClause1, WhereClause pWhereClause2 ) {
            super( WhereClauseType.OR, pWhereClause1, pWhereClause2 );
        }
    }

    private static class WC_AND extends AbstractWhereClauseAssociativeList {
        static WhereClause create( WhereClause pWhereClause1, WhereClause pWhereClause2 ) {
            verifyNotNull( pWhereClause1, pWhereClause2 );
            if ( pWhereClause1 == WC_FALSE.INSTANCE ) {
                return pWhereClause1;
            }
            if ( pWhereClause2 == WC_FALSE.INSTANCE ) {
                return pWhereClause2;
            }
            return (pWhereClause1 == WC_TRUE.INSTANCE) ? pWhereClause2 : //
                   (pWhereClause2 == WC_TRUE.INSTANCE) ? pWhereClause1 : //
                   new WC_AND( pWhereClause1, pWhereClause2 );
        }

        private WC_AND( WhereClause pWhereClause1, WhereClause pWhereClause2 ) {
            super( WhereClauseType.AND, pWhereClause1, pWhereClause2 );
        }
    }

    private static class WC_NOT extends AbstractWhereClauseWrapper {
        WC_NOT( WhereClause pWrappedWhereClause ) {
            super( WhereClauseType.NOT, pWrappedWhereClause );
        }
    }

    private static class WC_IS_NULL extends AbstractWhereClauseColumnAndTypeTo {
        WC_IS_NULL( SimpleColumnDefinition pColumnDefinition ) {
            super( WhereClauseType.IS_NULL, pColumnDefinition );
        }
    }

    private static class WC_EQUALS extends AbstractWhereClauseColumnAndValue {
        WC_EQUALS( SimpleColumnDefinition pColumnDefinition, Object pValue ) {
            super( WhereClauseType.EQUALS, pColumnDefinition, pValue );
        }

        @Override
        protected void LLtoSqlHelper( StringBuilder pSB ) {
            if ( !isNot() ) // Regular
            {
                super.LLtoSqlHelper( pSB );
            } else {
                pSB.append( '(' );
                super.LLtoSqlHelper( pSB );
                pSB.append( ") OR (" );
                toSqlColumnReference( pSB );
                pSB.append( " IS NULL)" );
            }
        }
    }

    private static class WC_LESSTHAN extends AbstractWhereClauseColumnAndValue {
        WC_LESSTHAN( SimpleColumnDefinition pColumnDefinition, Object pValue ) {
            super( WhereClauseType.LESSTHAN, pColumnDefinition, pValue );
        }
    }

    private static class WC_GREATERTHAN extends AbstractWhereClauseColumnAndValue {
        WC_GREATERTHAN( SimpleColumnDefinition pColumnDefinition, Object pValue ) {
            super( WhereClauseType.GREATERTHAN, pColumnDefinition, pValue );
        }
    }

    private static class WC_BETWEEN extends AbstractWhereClauseColumnAndTwoValues {
        WC_BETWEEN( SimpleColumnDefinition pColumnDefinition, Object pLeftValue, Object pRightValue ) {
            super( WhereClauseType.BETWEEN, pColumnDefinition, pLeftValue, pRightValue );
        }

        @Override
        protected void toStringHelper( StringBuilder pSB ) {
            if ( !isNot() ) {
                cuteStringHelper( pSB );
            } else {
                pSB.append( "NOT (" );
                cuteStringHelper( pSB );
                pSB.append( ')' );
            }
        }

        private void cuteStringHelper( StringBuilder pSB ) {
            WhereClauseColumnSupport.makeStringValue( pSB, getColumnDefinition(), getLeftValue() );
            pSB.append( " <= " );
            toStringColumnReference( pSB );
            pSB.append( " <= " );
            WhereClauseColumnSupport.makeStringValue( pSB, getColumnDefinition(), getRightValue() );
        }

        @Override
        protected final void toSqlHelper( WCtoSqlHelper pWCtoSqlHelper, StringBuilder pSB ) {
            if ( !pWCtoSqlHelper.preRender( this, pSB ) ) {
                toSqlColumnReference( pSB );
                pSB.append( ' ' );
                pSB.append( isNot() ? getType().getToNotSql() : getType().getToSql() );
                pSB.append( ' ' );
                WhereClauseColumnSupport.makeSqlValue( pSB, getColumnDefinition(), true, getLeftValue() );
                pSB.append( " AND " );
                WhereClauseColumnSupport.makeSqlValue( pSB, getColumnDefinition(), true, getRightValue() );

                pWCtoSqlHelper.postRender( this, pSB );
            }
        }
    }

    private static class WC_IS_ANY_OF extends AbstractWhereClauseColumnAnd_N_Values {
        WC_IS_ANY_OF( SimpleColumnDefinition pColumnDefinition, Object... pValues ) {
            super( WhereClauseType.IS_ANY_OF, pColumnDefinition, pValues );
        }
    }

    private static class WC_LIKE extends AbstractWhereClauseColumnAndLikeValues {
        WC_LIKE( SimpleColumnDefinition pColumnDefinition, String[] pValues ) {
            super( WhereClauseType.LIKE, pColumnDefinition, pValues );
        }
    }

    private static class WC_CONTAINS extends AbstractWhereClauseColumnAndLikeValue {
        WC_CONTAINS( SimpleColumnDefinition pColumnDefinition, String pValue ) {
            super( WhereClauseType.CONTAINS, pColumnDefinition, pValue );
        }

        @Override
        protected String[] getSqlLikeValues() {
            return new String[]{"", getValue(), ""};
        }
    }

    private static class WC_STARTS_WITH extends AbstractWhereClauseColumnAndLikeValue {
        WC_STARTS_WITH( SimpleColumnDefinition pColumnDefinition, String pValue ) {
            super( WhereClauseType.STARTS_WITH, pColumnDefinition, pValue );
        }

        @Override
        protected String[] getSqlLikeValues() {
            return new String[]{getValue(), ""};
        }
    }

    private static class WC_ENDS_WITH extends AbstractWhereClauseColumnAndLikeValue {
        WC_ENDS_WITH( SimpleColumnDefinition pColumnDefinition, String pValue ) {
            super( WhereClauseType.ENDS_WITH, pColumnDefinition, pValue );
        }

        @Override
        protected String[] getSqlLikeValues() {
            return new String[]{"", getValue()};
        }
    }

    private static class WC_IS_IN extends AbstractWhereClauseColumnIsIn {
        WC_IS_IN( SimpleColumnDefinition pColumnDefinition, SingleColumnSelect pSingleColumnSelect ) {
            super( WhereClauseType.IS_IN, pColumnDefinition, pSingleColumnSelect );
        }
    }

    private static class WC_TRUE extends AbstractWhereClauseTF {
        public static final WhereClause INSTANCE = new WC_TRUE();

        private WC_TRUE() {
            super( WhereClauseType.TRUE );
        }
    }

    private static class WC_FALSE extends AbstractWhereClauseTF {
        public static final WhereClause INSTANCE = new WC_FALSE();

        private WC_FALSE() {
            super( WhereClauseType.FALSE );
        }
    }
}
